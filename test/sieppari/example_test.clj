(ns sieppari.example-test
  (:require [clojure.test :refer :all]
            [testit.core :refer :all]
            [ring.util.http-response :as resp]
            [sieppari.core :as c]
            [sieppari.execute :as e]
            [clojure.core.async :as a :refer [go <! >!]]))

(def db {:users {"1" {:id "1", :username "John", :email "john@mit.edu"}
                 "2" {:id "2", :username "Alan", :email "alan@bletchley.co.uk"}}})

(def db-interceptor
  "Add the `db` into `ctx`."
  {:name :db
   :enter (fn [ctx]
            (assoc ctx :db db))})

(def session-interceptor
  "Add user data to request. Get user-id from request header \"X-Apikey\" and get
   user data from db. If user-if is not found respond unauthorized, if user is
   not found respond not-found."
  {:name :session
   ;; depends on :db and :http-resp interceptors:
   :depends #{:db}
   ;; Apply this interceptor only if target has declared `:session? true`:
   :applies-to? (fn [target] (-> target :session?))
   :enter (fn [ctx]
            (let [user-id (-> ctx
                              :request
                              :headers
                              (get "x-apikey"))
                  user (-> ctx
                           :db
                           :users
                           (get user-id))]
              (cond
                (nil? user-id) (assoc ctx :response (resp/unauthorized))
                (nil? user) (assoc ctx :response (resp/not-found))
                :else (update ctx :request assoc :user user))))})

(def http-resp-interceptor
  "Handle exceptions that are generated by resp/not-found! and friends."
  {:name :http-resp
   :error (fn [ctx]
            (let [{:keys [type response]} (-> ctx :exception ex-data)]
              (when (= type ::resp/response)
                (-> ctx
                    (assoc :response response)
                    (dissoc :exception)))))})

(def my-interceptors [db-interceptor
                      session-interceptor
                      http-resp-interceptor])

(defn handler
  "Get username from user information and message from body, return
  message with a greeting."
  {:session? true}
  [request]
  (let [username (-> request :user :username)
        message (-> request :body :message)]
    (resp/ok (str message ", " username))))

(def interceptor-chain (c/into-interceptors my-interceptors handler (meta #'handler)))

(deftest execute-test
  (fact
    (->> {:body {:message "Hullo"}
          :headers {"x-apikey" "1"}}
         (e/execute interceptor-chain))
    => {:status 200
        :body "Hullo, John"})
  (fact
    (->> {:body {:message "Hullo"}
          :headers {"x-apikey" "2"}}
         (e/execute interceptor-chain))
    => {:status 200
        :body "Hullo, Alan"})
  (fact
    (->> {:body {:message "Hullo"}
          :headers {"x-apikey" "3"}}
         (e/execute interceptor-chain))
    => {:status 404})
  (fact
    (->> {:body {:message "Hullo"}
          :headers {}}
         (e/execute interceptor-chain))
    => {:status 401}))

(def compiled-chain (e/compile-interceptor-chain interceptor-chain))


(deftest compile-interceptor-chain-test
  (fact
    (->> {:body {:message "Hullo"}
          :headers {"x-apikey" "1"}}
         (compiled-chain))
    => {:status 200
        :body "Hullo, John"})
  (fact
    (->> {:body {:message "Hullo"}
          :headers {"x-apikey" "2"}}
         (compiled-chain))
    => {:status 200
        :body "Hullo, Alan"})
  (fact
    (->> {:body {:message "Hullo"}
          :headers {"x-apikey" "3"}}
         (compiled-chain))
    => {:status 404})
  (fact
    (->> {:body {:message "Hullo"}
          :headers {}}
         (compiled-chain))
    => {:status 401}))

(comment
  (require 'criterium.core)
  (let [request {:body {:message "Hullo"}
                 :headers {"x-apikey" "1"}}]
    (println "\n\ne/execute:")
    (criterium.core/quick-bench
      (e/execute interceptor-chain request))
    (println "\n\ne/compiled:")
    (criterium.core/quick-bench
      (compiled-chain request)))

  )
